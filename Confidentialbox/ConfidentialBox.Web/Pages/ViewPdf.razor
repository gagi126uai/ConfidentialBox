@page "/view-pdf/{ShareLink}"
@attribute [AllowAnonymous]
@inject IFileService FileService
@inject IPdfViewerService PdfViewerService
@inject IJSRuntime JS
@using System.Collections.Generic
@using System.Linq
@using System.Security.Cryptography
@using System.Text.Json
@using ConfidentialBox.Core.DTOs
@implements IAsyncDisposable

<PageTitle>Visor Seguro - ConfidentialBox</PageTitle>

<div class="container py-4">
    <div class="row justify-content-center">
        <div class="col-xl-10">
            <div class="card shadow-sm">
                <div class="card-body p-4">
                    <h1 class="h4 mb-3"><i class="fas fa-file-pdf text-danger"></i> Visor Seguro de PDF</h1>

                    @if (!string.IsNullOrEmpty(errorMessage))
                    {
                        <div class="alert alert-danger">@errorMessage</div>
                    }

                    @if (!string.IsNullOrEmpty(infoMessage))
                    {
                        <div class="alert alert-info" role="status">@infoMessage</div>
                    }

                    @if (isLoading)
                    {
                        <div class="text-center py-5">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Cargando...</span>
                            </div>
                        </div>
                    }
                    else
                    {
                        var showFileDetails = viewerConfig?.EffectivePermissions?.FileDetailsVisible
                            ?? viewerConfig?.ViewerSettings?.ShowFileDetails
                            ?? true;

                        if (fileMetadata != null && showFileDetails)
                        {
                            <div class="secure-file-summary mb-4">
                                <div class="secure-file-summary__header">
                                    <div>
                                        <h2 class="secure-file-summary__title">
                                            <i class="fas @(fileMetadata.IsPdf ? "fa-file-pdf text-danger" : "fa-file text-primary") me-2"></i>
                                            @fileMetadata.OriginalFileName
                                        </h2>
                                        <p class="secure-file-summary__subtitle text-muted mb-0">
                                            <i class="fas fa-user-shield me-2"></i>@fileMetadata.UploadedByUserName
                                        </p>
                                    </div>
                                    <div class="secure-file-summary__badges text-end">
                                        <span class="badge rounded-pill bg-dark-subtle text-dark me-2">
                                            <i class="fas fa-database me-1"></i>@FormatBytes(fileMetadata.FileSizeBytes)
                                        </span>
                                        <span class="badge rounded-pill bg-secondary-subtle text-dark">
                                            <i class="fas fa-clock me-1"></i>@fileMetadata.UploadedAt.ToLocalTime().ToString("dd/MM/yyyy HH:mm")
                                        </span>
                                    </div>
                                </div>
                                <div class="secure-file-summary__grid">
                                    <div class="secure-file-summary__item">
                                        <span class="label">Extensión</span>
                                        <strong>@(string.IsNullOrWhiteSpace(fileMetadata.FileExtension) ? "-" : fileMetadata.FileExtension.ToUpperInvariant())</strong>
                                    </div>
                                    <div class="secure-file-summary__item">
                                        <span class="label">Compartido como</span>
                                        <strong><code>@fileMetadata.ShareLink</code></strong>
                                    </div>
                                    <div class="secure-file-summary__item">
                                        <span class="label">Accesos actuales</span>
                                        <strong>@fileMetadata.CurrentAccessCount @(fileMetadata.MaxAccessCount.HasValue ? $"/ {fileMetadata.MaxAccessCount}" : string.Empty)</strong>
                                    </div>
                                    <div class="secure-file-summary__item">
                                        <span class="label">Expira</span>
                                        <strong>@(fileMetadata.ExpiresAt.HasValue ? fileMetadata.ExpiresAt.Value.ToLocalTime().ToString("dd/MM/yyyy HH:mm") : "Sin vencimiento")</strong>
                                    </div>
                                </div>
                                @if (viewerConfig?.EffectivePermissions is not null)
                                {
                                    var protectionChips = BuildProtectionChips(viewerConfig.EffectivePermissions);
                                    if (protectionChips.Any())
                                    {
                                        <div class="secure-file-summary__protections">
                                            @foreach (var chip in protectionChips)
                                            {
                                                <span class="secure-chip @chip.CssClass"><i class="@chip.Icon me-1"></i>@chip.Text</span>
                                            }
                                        </div>
                                    }
                                }
                            </div>
                        }
                        else if (fileMetadata == null)
                        {
                            <div class="alert alert-info">
                                Ingresa la contraseña maestra para abrir el documento en el visor seguro.
                            </div>
                        }

                        if (sessionId == null)
                        {
                            <EditForm Model="@formModel" OnValidSubmit="StartSecureViewer">
                                <div class="row g-3 align-items-end">
                                    <div class="col-md-6">
                                        <label class="form-label">Contraseña maestra (si corresponde)</label>
                                        <InputText @bind-Value="formModel.MasterPassword" type="password" class="form-control" />
                                    </div>
                                    <div class="col-md-6 text-md-end">
                                        <button class="btn btn-danger" type="submit" disabled="@isStarting">
                                            @if (isStarting)
                                            {
                                                <span class="spinner-border spinner-border-sm me-2"></span>
                                            }
                                            <i class="fas fa-shield-alt"></i> Abrir visor seguro
                                        </button>
                                    </div>
                                </div>
                            </EditForm>
                        }
                    }

                    @if (pdfLoaded && viewerConfig != null)
                    {
                        <div class="secure-pdf-container mt-4" id="@ViewerContainerElementId">
                            <div class="secure-pdf-toolbar" id="@ToolbarElementId"></div>
                            <div class="secure-pdf-frame" id="@PdfFrameElementId"></div>
                        </div>
                        @if (viewerConfig?.AIMonitoringEnabled ?? false)
                        {
                            <p class="text-muted small mt-2">
                                <i class="fas fa-robot"></i> Monitoreo IA activo: intentos sospechosos bloquearán automáticamente el acceso.
                            </p>
                        }
                    }
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter]
    public string ShareLink { get; set; } = string.Empty;

    private FileDto? fileMetadata;
    private FileAccessResultDto? metadataSummary;
    private PDFViewerConfigDto? viewerConfig;
    private string? sessionId;
    private SecureViewerForm formModel = new();
    private bool pdfLoaded;
    private string? errorMessage;
    private string? infoMessage;
    private bool isLoading = true;
    private bool isStarting;
    private bool viewerBlocked;
    private bool fileBlocked;
    private bool blockedByAi;
    private string? blockedReason;
    private DotNetObjectReference<ViewPdf>? dotNetReference;
    private const string PdfFrameElementId = "securePdfFrame";
    private const string ViewerContainerElementId = "secureViewerContainer";
    private const string ToolbarElementId = "securePdfToolbar";
    private bool shouldAutoStartViewer;
    private bool secureViewerScriptReady;
    private bool blockerAlertShown;
    private readonly List<ViewerSecurityAlert> securityAlerts = new();

    private static readonly IReadOnlyDictionary<string, ViewerSecurityAlertTemplate> SecurityAlertTemplates =
        new Dictionary<string, ViewerSecurityAlertTemplate>(StringComparer.OrdinalIgnoreCase)
        {
            ["DownloadAttempt"] = new("Intento de descarga bloqueado por la configuración del visor.", "alert-warning", "fas fa-download"),
            ["PrintAttempt"] = new("Intento de impresión bloqueado por la política de seguridad.", "alert-warning", "fas fa-print"),
            ["CopyAttempt"] = new("Intento de copiado de texto bloqueado en este documento.", "alert-warning", "fas fa-copy"),
            ["ContextMenuBlocked"] = new("El menú contextual está bloqueado en el visor seguro.", "alert-info", "fas fa-ban"),
            ["DeveloperToolsDetected"] = new("Se detectó la apertura de herramientas de desarrollo. La sesión fue marcada para revisión.", "alert-danger", "fas fa-user-secret")
        };

    protected override async Task OnInitializedAsync()
    {
        await LoadMetadata();
    }

    private async Task LoadMetadata()
    {
        try
        {
            isLoading = true;
            errorMessage = null;
            infoMessage = null;
            fileBlocked = false;
            blockedByAi = false;
            blockedReason = null;
            viewerBlocked = false;
            shouldAutoStartViewer = false;
            blockerAlertShown = false;
            metadataSummary = await FileService.AccessFileAsync(ShareLink, null);
            fileMetadata = metadataSummary?.File;
            viewerBlocked = metadataSummary?.Blocked ?? false;

            if (metadataSummary == null)
            {
                errorMessage = "No fue posible cargar la información del PDF.";
                return;
            }

            if (metadataSummary.Blocked)
            {
                fileBlocked = true;
                blockedByAi = metadataSummary.BlockedByAi;
                blockedReason = metadataSummary.BlockReason ?? metadataSummary.ErrorMessage;
                blockedReason ??= blockedByAi
                    ? "La IA no proporcionó un motivo específico."
                    : "Motivo no disponible.";
                errorMessage = blockedByAi
                    ? $"La IA bloqueó este archivo: {blockedReason}"
                    : $"Este archivo está bloqueado: {blockedReason}";
                await ShowBlockerAlertAsync(blockedReason, blockedByAi);
                return;
            }

            if (fileMetadata == null || !fileMetadata.IsPdf)
            {
                errorMessage = "No fue posible cargar la información del PDF.";
            }
            else if (metadataSummary.RequiresPassword == false)
            {
                shouldAutoStartViewer = true;
            }
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
        }
        finally
        {
            isLoading = false;
            if (shouldAutoStartViewer)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task StartSecureViewer()
    {
        shouldAutoStartViewer = false;
        formModel ??= new SecureViewerForm();
        blockerAlertShown = false;

        if (fileMetadata == null)
        {
            errorMessage = "Archivo no disponible.";
            return;
        }

        if (fileBlocked)
        {
            errorMessage = blockedByAi
                ? $"La IA bloqueó este archivo: {blockedReason}"
                : $"Este archivo está bloqueado: {blockedReason}";
            return;
        }

        try
        {
            isStarting = true;
            viewerBlocked = false;
            blockedReason = null;
            blockedByAi = false;
            errorMessage = null;
            infoMessage = null;
            pdfLoaded = false;

            await EnsureSecureViewerScriptAsync();

            if (sessionId != null)
            {
                await PdfViewerService.EndSessionAsync(sessionId);
                await JS.InvokeVoidAsync("ConfidentialBox.disposeSecurePdfViewer", sessionId);
                sessionId = null;
            }

            await JS.InvokeVoidAsync("ConfidentialBox.disposePdfFrame", PdfFrameElementId);

            var startResponse = await PdfViewerService.StartSessionAsync(new StartViewerSessionRequest
            {
                ShareLink = ShareLink,
                MasterPassword = formModel.MasterPassword
            });

            if (startResponse == null || !startResponse.Success || startResponse.Config == null || string.IsNullOrEmpty(startResponse.SessionId))
            {
                errorMessage = startResponse?.ErrorMessage ?? "No fue posible iniciar la sesión segura.";
                return;
            }

            viewerConfig = startResponse.Config;
            sessionId = startResponse.SessionId;
            formModel.MasterPassword = null;

            var content = await PdfViewerService.GetSessionContentAsync(sessionId);
            if (content == null || !content.Success)
            {
                errorMessage = content?.ErrorMessage ?? "No fue posible recuperar el PDF cifrado.";
                return;
            }

            var decryptedBytes = DecryptContent(content.EncryptedContent, content.EncryptionKey);
            var base64Content = Convert.ToBase64String(decryptedBytes);

            fileMetadata ??= new FileDto
            {
                OriginalFileName = content.FileName,
                FileExtension = content.FileExtension,
                FileSizeBytes = decryptedBytes.LongLength,
                ShareLink = ShareLink,
                IsPdf = true
            };

            dotNetReference?.Dispose();
            dotNetReference = DotNetObjectReference.Create(this);

            securityAlerts.Clear();
            pdfLoaded = true;
            await InvokeAsync(StateHasChanged);

            await JS.InvokeVoidAsync(
                "ConfidentialBox.renderPdf",
                PdfFrameElementId,
                base64Content,
                viewerConfig.FileName);

            await JS.InvokeVoidAsync(
                "ConfidentialBox.initSecurePdfViewer",
                ViewerContainerElementId,
                new
                {
                    sessionId,
                    dotNetRef = dotNetReference,
                    frameId = PdfFrameElementId,
                    toolbarId = ToolbarElementId,
                    watermarkText = (viewerConfig.HasWatermark || (viewerConfig.ViewerSettings?.ForceGlobalWatermark ?? false))
                        ? viewerConfig.WatermarkText
                        : string.Empty,
                    watermarkStyle = new
                    {
                        color = viewerConfig.WatermarkColor,
                        opacity = viewerConfig.WatermarkOpacity,
                        fontSize = viewerConfig.WatermarkFontSize,
                        rotation = viewerConfig.WatermarkRotationDegrees
                    },
                    disableContextMenu = viewerConfig.ScreenshotProtectionEnabled
                        || (viewerConfig.ViewerSettings?.DisableContextMenu ?? false),
                    maxViewMinutes = viewerConfig.MaxViewTimeMinutes,
                    settings = viewerConfig.ViewerSettings,
                    policy = viewerConfig.EffectivePermissions,
                    fileName = viewerConfig.FileName
                });

            await JS.InvokeVoidAsync("ConfidentialBox.notifyPdfPage", sessionId, 1);
            infoMessage = "Visor seguro inicializado. La IA monitorea en tiempo real.";
        }
        catch (Exception ex)
        {
            pdfLoaded = false;
            errorMessage = ex.Message;
        }
        finally
        {
            isStarting = false;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if ((firstRender || shouldAutoStartViewer) && shouldAutoStartViewer && !isStarting && !pdfLoaded && !fileBlocked && metadataSummary?.RequiresPassword == false)
        {
            try
            {
                await StartSecureViewer();
            }
            catch (Exception ex)
            {
                errorMessage = ex.Message;
            }
            finally
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    [JSInvokable]
    public async Task ReportViewerEvent(string eventType, int? pageNumber, string? eventData)
    {
        if (sessionId == null)
        {
            return;
        }

        // Ejecutar TryAppendSecurityAlert sin asignar el resultado a una variable
        await InvokeAsync(() => TryAppendSecurityAlert(eventType, eventData));

        var result = await PdfViewerService.RecordEventAsync(new ViewerEventRequest
        {
            SessionId = sessionId,
            EventType = eventType,
            PageNumber = pageNumber,
            EventData = eventData
        });

        if (result?.Blocked == true)
        {
            viewerBlocked = true;
            fileBlocked = true;
            blockedByAi = true;
            blockedReason = result.Reason ?? "Comportamiento bloqueado.";
            blockedReason ??= "Comportamiento bloqueado.";
            infoMessage = null;
            pdfLoaded = false;

            await EnsureSecureViewerScriptAsync();
            await JS.InvokeVoidAsync("ConfidentialBox.disposePdfFrame", PdfFrameElementId);

            if (sessionId != null)
            {
                await PdfViewerService.EndSessionAsync(sessionId);
                await JS.InvokeVoidAsync("ConfidentialBox.disposeSecurePdfViewer", sessionId);
                sessionId = null;
            }

            await ShowBlockerAlertAsync(blockedReason, true);
        }

        // Llamar a StateHasChanged para refrescar el estado
        await InvokeAsync(StateHasChanged);
    }


    private async Task EnsureSecureViewerScriptAsync()
    {
        if (secureViewerScriptReady)
        {
            return;
        }

        await JS.InvokeVoidAsync("ConfidentialBox.ensureSecureViewerReady");
        secureViewerScriptReady = true;
    }

    private static byte[] DecryptContent(string encryptedContent, string encryptionKey)
    {
        var cipher = Convert.FromBase64String(encryptedContent);
        var key = Convert.FromBase64String(encryptionKey);

        using var aes = Aes.Create();
        aes.Key = key;

        var iv = new byte[aes.BlockSize / 8];
        Buffer.BlockCopy(cipher, 0, iv, 0, iv.Length);
        aes.IV = iv;

        using var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
        using var ms = new MemoryStream(cipher, iv.Length, cipher.Length - iv.Length);
        using var cryptoStream = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);
        using var result = new MemoryStream();
        cryptoStream.CopyTo(result);
        return result.ToArray();
    }

    private static string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private static IEnumerable<ProtectionChip> BuildProtectionChips(PDFViewerPermissionsDto settings)
    {
        if (settings.DownloadAllowed || settings.DownloadButtonVisible)
        {
            yield return new ProtectionChip(
                settings.DownloadAllowed ? "chip-allowed" : "chip-blocked",
                settings.DownloadAllowed ? "fas fa-download" : "fas fa-ban",
                settings.DownloadAllowed ? "Descarga habilitada" : "Descarga bloqueada");
        }

        if (settings.PrintAllowed || settings.PrintButtonVisible)
        {
            yield return new ProtectionChip(
                settings.PrintAllowed ? "chip-allowed" : "chip-blocked",
                settings.PrintAllowed ? "fas fa-print" : "fas fa-ban",
                settings.PrintAllowed ? "Impresión permitida" : "Impresión bloqueada");
        }

        yield return new ProtectionChip(
            settings.CopyAllowed ? "chip-allowed" : "chip-blocked",
            settings.CopyAllowed ? "fas fa-copy" : "fas fa-ban",
            settings.CopyAllowed ? "Copiado habilitado" : "Copiado bloqueado");

        yield return new ProtectionChip(
            settings.ContextMenuBlocked ? "chip-blocked" : "chip-allowed",
            settings.ContextMenuBlocked ? "fas fa-hand" : "fas fa-mouse",
            settings.ContextMenuBlocked ? "Menú contextual bloqueado" : "Menú contextual permitido");

        yield return new ProtectionChip(
            settings.TextSelectionBlocked ? "chip-blocked" : "chip-allowed",
            settings.TextSelectionBlocked ? "fas fa-font" : "fas fa-font",
            settings.TextSelectionBlocked ? "Selección deshabilitada" : "Selección habilitada");

        if (settings.MaxViewTimeMinutes > 0)
        {
            yield return new ProtectionChip(
                "chip-warning",
                "fas fa-hourglass-half",
                $"Tiempo máximo: {settings.MaxViewTimeMinutes} min");
        }
    }

    private bool TryAppendSecurityAlert(string eventType, string? eventData)
    {
        if (string.IsNullOrWhiteSpace(eventType))
        {
            return false;
        }

        if (string.Equals(eventType, "ScreenshotAttempt", StringComparison.OrdinalIgnoreCase))
        {
            var trigger = ExtractEventValue(eventData, "trigger");
            var triggerText = DescribeScreenshotTrigger(trigger);
            var message = triggerText != null
                ? $"Intento de captura de pantalla detectado ({triggerText}). La actividad quedó registrada."
                : "Intento de captura de pantalla detectado. La actividad quedó registrada.";
            var alert = new ViewerSecurityAlert(eventType, message, "alert-danger", "fas fa-camera", DateTimeOffset.UtcNow);
            AppendSecurityAlert(alert);
            TriggerSweetAlert(alert);
            return true;
        }

        if (SecurityAlertTemplates.TryGetValue(eventType, out var template))
        {
            var alert = new ViewerSecurityAlert(eventType, template.Message, template.CssClass, template.Icon, DateTimeOffset.UtcNow);
            AppendSecurityAlert(alert);
            TriggerSweetAlert(alert);
            return true;
        }

        return false;
    }

    private void AppendSecurityAlert(ViewerSecurityAlert alert)
    {
        ViewerSecurityAlert? lastAlert = securityAlerts.Count > 0 ? securityAlerts[^1] : null;
        if (lastAlert != null && lastAlert.Message == alert.Message && (alert.Timestamp - lastAlert.Timestamp).TotalSeconds < 2)
        {
            return;
        }

        securityAlerts.Add(alert);

        const int maxAlerts = 5;
        while (securityAlerts.Count > maxAlerts)
        {
            securityAlerts.RemoveAt(0);
        }
    }

    private void TriggerSweetAlert(ViewerSecurityAlert alert)
    {
        var icon = MapCssClassToSweetIcon(alert.CssClass);
        _ = InvokeAsync(() => ShowSweetAlertAsync("Alerta de seguridad", alert.Message, icon));
    }

    private static string MapCssClassToSweetIcon(string? cssClass)
    {
        if (string.IsNullOrWhiteSpace(cssClass))
        {
            return "info";
        }

        if (cssClass.Contains("danger", StringComparison.OrdinalIgnoreCase))
        {
            return "error";
        }

        if (cssClass.Contains("warning", StringComparison.OrdinalIgnoreCase))
        {
            return "warning";
        }

        if (cssClass.Contains("success", StringComparison.OrdinalIgnoreCase))
        {
            return "success";
        }

        return "info";
    }

    private ValueTask ShowSweetAlertAsync(string title, string? message, string icon = "info")
    {
        return JS.InvokeVoidAsync("ConfidentialBox.showSweetAlert", new
        {
            title,
            message,
            icon
        });
    }

    private async Task ShowBlockerAlertAsync(string? reason, bool byAi)
    {
        if (blockerAlertShown)
        {
            return;
        }

        blockerAlertShown = true;

        var title = byAi ? "Acceso bloqueado por IA" : "Acceso bloqueado";
        var message = string.IsNullOrWhiteSpace(reason) ? "La sesión fue bloqueada." : reason;
        var icon = byAi ? "error" : "warning";
        await ShowSweetAlertAsync(title, message, icon);
    }

    private static string? ExtractEventValue(string? eventData, string propertyName)
    {
        if (string.IsNullOrWhiteSpace(eventData) || string.IsNullOrWhiteSpace(propertyName))
        {
            return null;
        }

        try
        {
            using var document = JsonDocument.Parse(eventData);
            if (document.RootElement.TryGetProperty(propertyName, out var property))
            {
                return property.ValueKind == JsonValueKind.String ? property.GetString() : property.ToString();
            }
        }
        catch (JsonException)
        {
            // Ignore malformed payloads from the browser; the event was still recorded.
        }

        return null;
    }

    private static string? DescribeScreenshotTrigger(string? trigger)
    {
        return trigger switch
        {
            "KeyDown" or "KeyUp" => "tecla Impr Pant",
            "SystemCaptureShortcut" => "atajo de captura del sistema",
            "SnippingShortcut" => "herramienta Recortes",
            { Length: > 0 } => trigger,
            _ => null
        };
    }

    private static string FormatAlertTimestamp(ViewerSecurityAlert alert)
    {
        return alert.Timestamp.ToLocalTime().ToString("HH:mm:ss");
    }

    public async ValueTask DisposeAsync()
    {
        var currentSession = sessionId;

        if (currentSession != null)
        {
            await PdfViewerService.EndSessionAsync(currentSession);
        }

        if (currentSession != null || pdfLoaded)
        {
            try
            {
                await EnsureSecureViewerScriptAsync();

                if (currentSession != null)
                {
                    await JS.InvokeVoidAsync("ConfidentialBox.disposeSecurePdfViewer", currentSession);
                }

                await JS.InvokeVoidAsync("ConfidentialBox.disposePdfFrame", PdfFrameElementId);
            }
            catch (Microsoft.JSInterop.JSException)
            {
                // Ignore errors thrown while tearing down the browser viewer during prerendering.
            }
        }

        sessionId = null;
        dotNetReference?.Dispose();
        dotNetReference = null;
    }
    
    private async Task DisposePdfFrame()
    {
        try
        {
            await JS.InvokeVoidAsync("ConfidentialBox.disposePdfFrame", "securePdfFrame");
        }
        catch (Exception ex)
        {
            // Manejo de errores, por si el método no está definido
            Console.WriteLine($"Error al invocar disposePdfFrame: {ex.Message}");
        }
    }

    private async Task RenderPdf(string base64Content, string fileName)
    {
        try
        {
            await JS.InvokeVoidAsync("ConfidentialBox.renderPdf", "securePdfFrame", base64Content, fileName);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al invocar renderPdf: {ex.Message}");
        }
    }

    private sealed class SecureViewerForm
    {
        public string? MasterPassword { get; set; }
    }

    private sealed record ViewerSecurityAlert(string EventType, string Message, string CssClass, string Icon, DateTimeOffset Timestamp);

    private sealed record ViewerSecurityAlertTemplate(string Message, string CssClass, string Icon);

    private sealed record ProtectionChip(string CssClass, string Icon, string Text);
}
